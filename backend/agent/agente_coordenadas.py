#!/usr/bin/env python3
"""
Agente CrewAI con Gemini + PDFs de Madrid + Internet
Versi√≥n simplificada sin herramientas de delegaci√≥n
Ubicado en backend/agent para mejor organizaci√≥n
"""

import os
import sys
import requests
from bs4 import BeautifulSoup
from urllib.parse import quote_plus
import warnings
import json
import hashlib
from datetime import datetime
warnings.filterwarnings("ignore")

# Configuraci√≥n de variables de entorno
from dotenv import load_dotenv
load_dotenv()

# Imports principales
from crewai.llm import LLM
from langchain_huggingface import HuggingFaceEmbeddings
from langchain_community.vectorstores import FAISS
from langchain_community.document_loaders import PyPDFLoader
from langchain.text_splitter import RecursiveCharacterTextSplitter
from crewai import Agent, Task, Crew, Process
from crewai.tools import BaseTool
from typing import Type
from pydantic import BaseModel, Field

# Importar tareas desde archivo en la misma carpeta
from tareas_madrid import crear_tarea_guia_turistica

# Definir herramientas para CrewAI
class MadridPDFSearchInput(BaseModel):
    """Input para b√∫squeda en PDFs de Madrid"""
    query: str = Field(description="Consulta para buscar en los PDFs de Madrid")

class MadridPDFSearchTool(BaseTool):
    name: str = "madrid_pdf_search"
    description: str = "Busca informaci√≥n espec√≠fica en los PDFs oficiales de Madrid sobre turismo, historia y cultura"
    args_schema: Type[BaseModel] = MadridPDFSearchInput
    
    def _run(self, query: str) -> str:
        # Esta herramienta se configurar√° din√°micamente con el vectorstore
        return "Herramienta de b√∫squeda en PDFs configurada din√°micamente"

class InternetSearchInput(BaseModel):
    """Input para b√∫squeda en Internet"""
    query: str = Field(description="Consulta para buscar informaci√≥n en Internet")

class InternetSearchTool(BaseTool):
    name: str = "internet_search"
    description: str = "Busca informaci√≥n actualizada en Internet sobre Madrid, turismo y actividades"
    args_schema: Type[BaseModel] = InternetSearchInput
    
    def _run(self, query: str) -> str:
        return buscar_en_internet(query)

class LocationSearchInput(BaseModel):
    """Input para b√∫squeda de lugares cercanos"""
    lat: float = Field(description="Latitud")
    lon: float = Field(description="Longitud")
    radius_km: float = Field(default=1.0, description="Radio de b√∫squeda en kil√≥metros")
    category: str = Field(default="turismo", description="Categor√≠a de lugares a buscar")

class LocationSearchTool(BaseTool):
    name: str = "location_search"
    description: str = "Busca lugares cercanos usando coordenadas GPS y OpenStreetMap"
    args_schema: Type[BaseModel] = LocationSearchInput
    
    def _run(self, lat: float, lon: float, radius_km: float = 1.0, category: str = "turismo") -> str:
        radius_meters = int(radius_km * 1000)
        return buscar_lugares_openstreetmap(lat, lon, radius_meters, category)

def crear_llm_gemini():
    """Configura el LLM Gemini para CrewAI usando litellm"""
    try:
        api_key = os.getenv("GEMINI_API_KEY")
        if not api_key:
            raise ValueError("GEMINI_API_KEY no encontrada en variables de entorno")
        
        # Configurar variables de entorno para litellm
        os.environ["GEMINI_API_KEY"] = api_key
        
        # Usar configuraci√≥n compatible con CrewAI/litellm
        from crewai.llm import LLM
        
        llm = LLM(
            model="gemini/gemini-1.5-flash",
            api_key=api_key,
            temperature=0.7
        )
        
        print("‚úÖ LLM Gemini configurado correctamente para CrewAI")
        return llm
    except Exception as e:
        print(f"‚ùå Error configurando Gemini: {e}")
        sys.exit(1)

def obtener_info_pdfs(pdf_folder):
    """Obtiene informaci√≥n de los PDFs para verificar cambios"""
    if not os.path.exists(pdf_folder):
        return {}
    
    pdf_info = {}
    for filename in os.listdir(pdf_folder):
        if filename.endswith('.pdf'):
            filepath = os.path.join(pdf_folder, filename)
            # Usar timestamp de modificaci√≥n y tama√±o del archivo
            stat = os.stat(filepath)
            pdf_info[filename] = {
                'size': stat.st_size,
                'modified': stat.st_mtime
            }
    return pdf_info

def guardar_cache_info(cache_folder, pdf_info):
    """Guarda informaci√≥n del cach√©"""
    os.makedirs(cache_folder, exist_ok=True)
    cache_info_path = os.path.join(cache_folder, "cache_info.json")
    
    cache_data = {
        'created': datetime.now().isoformat(),
        'pdf_files': pdf_info
    }
    
    with open(cache_info_path, 'w', encoding='utf-8') as f:
        json.dump(cache_data, f, indent=2)

def cargar_cache_info(cache_folder):
    """Carga informaci√≥n del cach√©"""
    cache_info_path = os.path.join(cache_folder, "cache_info.json")
    if not os.path.exists(cache_info_path):
        return None
    
    try:
        with open(cache_info_path, 'r', encoding='utf-8') as f:
            return json.load(f)
    except:
        return None

def necesita_actualizacion(pdf_folder, cache_folder):
    """Verifica si el vectorstore necesita actualizaci√≥n"""
    # Verificar si existe el cache
    if not os.path.exists(cache_folder) or not os.path.exists(os.path.join(cache_folder, "index.faiss")):
        return True, "Cache no existe"
    
    # Obtener informaci√≥n actual de PDFs
    pdf_info_actual = obtener_info_pdfs(pdf_folder)
    
    # Cargar informaci√≥n del cache
    cache_info = cargar_cache_info(cache_folder)
    if not cache_info:
        return True, "Informaci√≥n de cache no v√°lida"
    
    pdf_info_cache = cache_info.get('pdf_files', {})
    
    # Comparar archivos
    if set(pdf_info_actual.keys()) != set(pdf_info_cache.keys()):
        return True, "Archivos diferentes"
    
    for filename, info_actual in pdf_info_actual.items():
        info_cache = pdf_info_cache.get(filename, {})
        if (info_actual.get('size') != info_cache.get('size') or 
            info_actual.get('modified') != info_cache.get('modified')):
            return True, f"Archivo modificado: {filename}"
    
    return False, "Cache v√°lido"

def cargar_vectorstore_cache(cache_folder, embeddings):
    """Carga vectorstore desde cach√©"""
    try:
        vectorstore = FAISS.load_local(
            cache_folder, 
            embeddings, 
            allow_dangerous_deserialization=True
        )
        return vectorstore
    except Exception as e:
        print(f"‚ö†Ô∏è Error cargando cache: {e}")
        return None

def guardar_vectorstore_cache(vectorstore, cache_folder):
    """Guarda vectorstore en cach√©"""
    try:
        os.makedirs(cache_folder, exist_ok=True)
        vectorstore.save_local(cache_folder)
        return True
    except Exception as e:
        print(f"‚ö†Ô∏è Error guardando cache: {e}")
        return False

def procesar_pdfs(pdf_folder, embeddings):
    """Procesa los PDFs y crea documentos"""
    documents = []
    text_splitter = RecursiveCharacterTextSplitter(
        chunk_size=1000,
        chunk_overlap=200
    )
    
    pdf_files = [f for f in os.listdir(pdf_folder) if f.endswith('.pdf')]
    
    for pdf_file in pdf_files:
        print(f"   üìÑ Procesando {pdf_file}...")
        pdf_path = os.path.join(pdf_folder, pdf_file)
        
        try:
            loader = PyPDFLoader(pdf_path)
            docs = loader.load()
            
            # Agregar metadata del archivo
            for doc in docs:
                doc.metadata['source_file'] = pdf_file
            
            split_docs = text_splitter.split_documents(docs)
            documents.extend(split_docs)
        except Exception as e:
            print(f"   ‚ö†Ô∏è Error procesando {pdf_file}: {e}")
    
    return documents, pdf_files

def inicializar_vectorstore():
    """Inicializa FAISS con los PDFs de Madrid usando sistema de cach√©"""
    print("üìö Inicializando vectorstore con PDFs de Madrid...")
    
    # Configurar rutas (ahora est√°n en el directorio backend)
    current_dir = os.path.dirname(os.path.abspath(__file__))
    backend_dir = os.path.join(current_dir, "..")
    pdf_folder = os.path.join(backend_dir, "pdfs_madrid")
    cache_folder = os.path.join(backend_dir, "vectorstore_cache")
    
    if not os.path.exists(pdf_folder):
        print(f"‚ùå Carpeta {pdf_folder} no encontrada")
        return None
    
    # Configurar embeddings
    embeddings = HuggingFaceEmbeddings(
        model_name="sentence-transformers/all-MiniLM-L6-v2",
        model_kwargs={'device': 'cpu'}
    )
    
    # Verificar si necesita actualizaci√≥n
    necesita_update, razon = necesita_actualizacion(pdf_folder, cache_folder)
    
    if not necesita_update:
        print(f"‚úÖ Cargando vectorstore desde cach√© ({razon})")
        vectorstore = cargar_vectorstore_cache(cache_folder, embeddings)
        if vectorstore:
            return vectorstore
        else:
            print("‚ö†Ô∏è Error cargando cach√©, regenerando...")
    
    print(f"üîÑ Actualizando vectorstore ({razon})")
    
    # Procesar PDFs
    documents, pdf_files = procesar_pdfs(pdf_folder, embeddings)
    
    if not documents:
        print("‚ùå No se pudieron cargar documentos")
        return None
    
    # Crear vectorstore
    vectorstore = FAISS.from_documents(documents, embeddings)
    print(f"‚úÖ Se procesaron {len(pdf_files)} PDFs en FAISS")
    
    # Guardar en cach√©
    if guardar_vectorstore_cache(vectorstore, cache_folder):
        pdf_info = obtener_info_pdfs(pdf_folder)
        guardar_cache_info(cache_folder, pdf_info)
        print("üíæ Vectorstore guardado en cach√©")
    
    return vectorstore

def buscar_en_pdfs(vectorstore, query, k=5):
    """Busca informaci√≥n en los PDFs usando FAISS"""
    if not vectorstore:
        return "No hay vectorstore disponible."
    
    try:
        results = vectorstore.similarity_search(query, k=k)
        
        if not results:
            return "No se encontr√≥ informaci√≥n relevante en los PDFs."
        
        # Organizar resultados por archivo
        info_by_file = {}
        for doc in results:
            filename = doc.metadata.get('source_file', 'archivo_desconocido')
            content = doc.page_content.strip()
            
            if filename not in info_by_file:
                info_by_file[filename] = []
            
            if content and len(content) > 50:  # Filtrar contenido muy corto
                info_by_file[filename].append(content[:500])  # Limitar tama√±o
        
        # Formatear respuesta
        response = "üîç **Informaci√≥n encontrada en PDFs de Madrid:**\n\n"
        for i, (filename, contents) in enumerate(info_by_file.items(), 1):
            response += f"**{i}. Documento: {filename}**\n"
            for content in contents[:2]:  # M√°ximo 2 fragmentos por archivo
                response += f"{content}...\n\n"
        
        return response
    except Exception as e:
        return f"Error buscando en PDFs: {e}"

def buscar_en_internet(query, max_results=3):
    """Busca informaci√≥n en Internet usando Google"""
    try:
        search_url = f"https://www.google.com/search?q={quote_plus(query + ' Madrid turismo')}"
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
        
        response = requests.get(search_url, headers=headers, timeout=10)
        if response.status_code != 200:
            return "No se pudo realizar b√∫squeda en Internet."
        
        soup = BeautifulSoup(response.content, 'html.parser')
        results = []
        
        # Buscar resultados de b√∫squeda
        for result in soup.find_all('div', class_='BVG0Nb')[:max_results]:
            title_elem = result.find('h3')
            snippet_elem = result.find('span')
            
            if title_elem and snippet_elem:
                title = title_elem.get_text().strip()
                snippet = snippet_elem.get_text().strip()
                if len(snippet) > 100:
                    results.append(f"**{title}**\n{snippet[:300]}...")
        
        if results:
            return "üåê **Informaci√≥n de Internet:**\n\n" + "\n\n".join(results)
        else:
            return "No se encontraron resultados relevantes en Internet."
    
    except Exception as e:
        return f"Error buscando en Internet: {e}"

def buscar_lugares_openstreetmap(lat, lon, radio_metros=1000, categoria=None):
    """
    Busca lugares cercanos usando OpenStreetMap Overpass API (gratuita)
    
    Args:
        lat (float): Latitud
        lon (float): Longitud
        radio_metros (int): Radio de b√∫squeda en metros
        categoria (str): Categor√≠a de lugar (opcional)
    
    Returns:
        str: Informaci√≥n formateada de los lugares encontrados
    """
    try:
        # URL de Overpass API (gratuita)
        url = "https://overpass-api.de/api/interpreter"
        
        # Mapear categor√≠as a tags de OpenStreetMap
        categoria_tags = {
            'museo': '["tourism"="museum"]',
            'restaurante': '["amenity"~"restaurant|cafe|bar"]',
            'hotel': '["tourism"~"hotel|guest_house"]',
            'parque': '["leisure"="park"]',
            'shopping': '["shop"]',
            'turismo': '["tourism"]',
            'entretenimiento': '["amenity"~"cinema|theatre"]',
            'cultura': '["tourism"~"museum|gallery|attraction"]'
        }
        
        # Construir query para Overpass
        if categoria and categoria.lower() in categoria_tags:
            tag_filter = categoria_tags[categoria.lower()]
        else:
            tag_filter = '["tourism"]'  # Por defecto, lugares tur√≠sticos
        
        query = f"""
        [out:json][timeout:25];
        (
          node{tag_filter}(around:{radio_metros},{lat},{lon});
          way{tag_filter}(around:{radio_metros},{lat},{lon});
          relation{tag_filter}(around:{radio_metros},{lat},{lon});
        );
        out center meta;
        """
        
        print(f"üîó Consultando OpenStreetMap Overpass API...")
        print(f"üìç Coordenadas: {lat}, {lon}")
        print(f"üìè Radio: {radio_metros}m")
        print(f"üè∑Ô∏è Categor√≠a: {categoria or 'turismo'}")
        print()
        
        # Hacer petici√≥n
        response = requests.post(url, data={'data': query}, timeout=30)
        
        if response.status_code == 200:
            data = response.json()
            return formatear_resultados_openstreetmap(data, lat, lon, radio_metros)
        else:
            return f"‚ùå Error en OpenStreetMap API: {response.status_code}"
            
    except Exception as e:
        return f"‚ùå Error conectando con OpenStreetMap API: {e}"

def formatear_resultados_openstreetmap(data, lat, lon, radio_metros):
    """
    Formatea los resultados de OpenStreetMap en texto legible
    """
    elementos = data.get('elements', [])
    
    if not elementos:
        return f"üó∫Ô∏è No se encontraron lugares cerca de ({lat}, {lon}) en un radio de {radio_metros/1000:.1f}km"
    
    resultado = f"üó∫Ô∏è **Lugares encontrados cerca de ({lat}, {lon}) - Radio: {radio_metros/1000:.1f}km**\n"
    resultado += f"üåç **Datos de OpenStreetMap (gratuito)**\n\n"
    
    # Agrupar por tipo
    por_categoria = {}
    
    for elemento in elementos:
        tags = elemento.get('tags', {})
        nombre = tags.get('name', 'Sin nombre')
        
        if nombre == 'Sin nombre':
            continue  # Saltar lugares sin nombre
        
        # Determinar categor√≠a
        if 'tourism' in tags:
            if tags['tourism'] == 'museum':
                categoria = 'Museo'
            elif tags['tourism'] == 'attraction':
                categoria = 'Atracci√≥n Tur√≠stica'
            elif tags['tourism'] == 'hotel':
                categoria = 'Hotel'
            else:
                categoria = 'Turismo'
        elif 'amenity' in tags:
            if tags['amenity'] in ['restaurant', 'cafe', 'bar']:
                categoria = 'Gastronom√≠a'
            elif tags['amenity'] in ['cinema', 'theatre']:
                categoria = 'Entretenimiento'
            else:
                categoria = 'Servicios'
        elif 'leisure' in tags:
            categoria = 'Ocio'
        elif 'shop' in tags:
            categoria = 'Comercio'
        else:
            categoria = 'General'
        
        # Obtener coordenadas del elemento
        if elemento['type'] == 'node':
            elem_lat = elemento.get('lat', 0)
            elem_lon = elemento.get('lon', 0)
        else:
            # Para ways y relations, usar el centro
            center = elemento.get('center', {})
            elem_lat = center.get('lat', 0)
            elem_lon = center.get('lon', 0)
        
        # Calcular distancia
        if elem_lat and elem_lon:
            import math
            R = 6371000  # Radio de la Tierra en metros
            lat1_rad = math.radians(lat)
            lat2_rad = math.radians(elem_lat)
            delta_lat = math.radians(elem_lat - lat)
            delta_lon = math.radians(elem_lon - lon)
            
            a = math.sin(delta_lat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(delta_lon/2)**2
            c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
            distancia = R * c
        else:
            distancia = 0
        
        # Agrupar por categor√≠a
        if categoria not in por_categoria:
            por_categoria[categoria] = []
        
        lugar_info = {
            'nombre': nombre,
            'distancia': distancia,
            'direccion': tags.get('addr:street', '') + ' ' + tags.get('addr:housenumber', ''),
            'website': tags.get('website', ''),
            'telefono': tags.get('phone', ''),
            'tipo': tags.get('tourism', tags.get('amenity', tags.get('leisure', tags.get('shop', '')))),
            'coordenadas': f"{elem_lat:.5f}, {elem_lon:.5f}"
        }
        
        por_categoria[categoria].append(lugar_info)
    
    # Formatear salida por categor√≠as
    for categoria, lugares_cat in por_categoria.items():
        resultado += f"**üìç {categoria.upper()}:**\n"
        
        # Ordenar por distancia
        lugares_cat.sort(key=lambda x: x['distancia'])
        
        for lugar in lugares_cat[:5]:  # M√°ximo 5 por categor√≠a
            resultado += f"‚Ä¢ **{lugar['nombre']}**"
            
            if lugar['distancia'] > 0:
                resultado += f" ({lugar['distancia']:.0f}m)"
            
            resultado += f"\n"
            
            if lugar['direccion'].strip():
                resultado += f"  üìç {lugar['direccion'].strip()}\n"
            
            if lugar['telefono']:
                resultado += f"  üìû {lugar['telefono']}\n"
            
            if lugar['website']:
                resultado += f"  üåê {lugar['website']}\n"
            
            if lugar['tipo']:
                resultado += f"  üè∑Ô∏è Tipo: {lugar['tipo']}\n"
            
            resultado += f"  üó∫Ô∏è Coordenadas: {lugar['coordenadas']}\n"
            resultado += "\n"
        
        resultado += "\n"
    
    return resultado

def main(user_query=None, vectorstore=None, llm=None, adulto=None, infantil=None, accesibilidad=None,
         lat=None, lon=None, radio_km=1.0, categoria_foursquare=None):
    """
    Funci√≥n principal con integraci√≥n de OpenStreetMap API
    
    Args:
        lat (float): Latitud para b√∫squeda de lugares cercanos
        lon (float): Longitud para b√∫squeda de lugares cercanos
        radio_km (float): Radio de b√∫squeda en kil√≥metros
        categoria_foursquare (str): Categor√≠a para filtrar lugares (museo, restaurante, etc.)
    """
    if infantil:
        user_query += " con actividades para ni√±os"
    if adulto:
        user_query += " con actividades para adultos"
    if accesibilidad:
        user_query += " con opciones accesibles"
    print(f"\nüîç Procesando consulta: {user_query}")
    
    # Buscar informaci√≥n en PDFs e Internet
    pdf_info = buscar_en_pdfs(vectorstore, user_query)
    web_info = buscar_en_internet(user_query)
    
    # B√∫squeda en OpenStreetMap si se proporcionan coordenadas
    lugares_info = ""
    if lat is not None and lon is not None:
        print(f"üåç Buscando lugares cercanos con OpenStreetMap API...")
        radio_metros = int(radio_km * 1000)  # Convertir a metros
        lugares_info = buscar_lugares_openstreetmap(lat, lon, radio_metros, categoria_foursquare)
    
    # Preparar informaci√≥n adicional
    info_adicional = ""
    if lugares_info:
        info_adicional = f"\n\nüåç LUGARES CERCANOS (OPENSTREETMAP):\n{lugares_info}"

    # Crear herramientas con informaci√≥n contextual
    pdf_search_tool = MadridPDFSearchTool()
    # Configurar la herramienta PDF con el vectorstore actual
    def pdf_search_with_context(query: str) -> str:
        return buscar_en_pdfs(vectorstore, query)
    pdf_search_tool._run = pdf_search_with_context

    internet_search_tool = InternetSearchTool()
    location_search_tool = LocationSearchTool()

    # Crear agente tur√≠stico (sin delegaci√≥n para evitar errores)
    guia_turistico_raton = Agent(
        role='El ratoncito P√©rez experto en turismo de Madrid. Su misi√≥n es ayudar a las familias a descubrir la ciudad de manera m√°gica y educativa.',
        goal='Proporcionar informaci√≥n tur√≠stica pr√°ctica y completa sobre Madrid',
        backstory="""Eres un experto gu√≠a tur√≠stico de Madrid con a√±os de experiencia. 
        Te especializas en informaci√≥n pr√°ctica: ubicaciones exactas, coordenadas GPS, 
        transporte p√∫blico, horarios, precios, y recomendaciones de itinerarios. 
        Tambi√©n tienes conocimientos de historia y cultura para crear gu√≠as completas.""",
        llm=llm,
        verbose=True,
        allow_delegation=False  # Deshabilitado para evitar errores
    )
    raton_perez_guide = Agent(
        role="El narrador m√°gico y gu√≠a encantado de la tripulaci√≥n. Es quien transforma los datos e informaci√≥n en una narrativa cohesiva, emocionante y personalizada para las familias. Se comunica directamente con los usuarios, entregando la experiencia final.",
        goal="Transformar una visita tur√≠stica en una aventura m√°gica e interactiva, mezclando hechos hist√≥ricos con cuentos fant√°sticos. Su objetivo es generar asombro, nostalgia y diversi√≥n, adaptando la experiencia para conectar a ni√±os y adultos por igual.",
        backstory="Soy el Rat√≥n P√©rez, un mago-creador cuidadoso que vive en el coraz√≥n de Madrid. Llevo siglos recolectando dientes, pero tambi√©n historias, secretos y leyendas de la ciudad. Mi misi√≥n no es solo guardar tesoros, sino tambi√©n compartirlos. He visto la ciudad crecer y cambiar, y ahora, con mis ayudantes, quiero revelar sus misterios y su encanto a todas las familias, convirtiendo cada rinc√≥n en un cap√≠tulo de un cuento de hadas.",
        llm=llm,
        verbose=True,
        allow_delegation=True
    )

    madrid_researcher = Agent(
        role="El historiador y erudito de la tripulaci√≥n. Su trabajo es investigar, recopilar y validar la informaci√≥n hist√≥rica, cultural y curiosa sobre los lugares emblem√°ticos de Madrid. Es el encargado de proveer los hechos y los datos que el equipo necesita para construir las historias.",
        goal="Encontrar datos hist√≥ricos, curiosidades y leyendas aut√©nticas sobre los monumentos, plazas y edificios de Madrid para enriquecer la experiencia de la familia. Su objetivo es asegurar que la narrativa del Rat√≥n P√©rez tenga una base s√≥lida y confiable.",
        backstory="Soy un incansable investigador con un ojo para los detalles. He pasado siglos en los archivos secretos de la Villa y Corte, descubriendo los misterios que se esconden en cada callejuela y cada piedra de la ciudad. Mi pasi√≥n es desenterrar los secretos mejor guardados y entregarlos a la tripulaci√≥n para que la magia del Rat√≥n P√©rez sea tan real como la historia misma.",
        llm=llm,
        verbose=True,
        allow_delegation=True,
        tools=[pdf_search_tool, internet_search_tool]
    )

    game_designer = Agent(
        role="El mago de los desaf√≠os y creador de aventuras. Se encarga de dise√±ar din√°micas de juego divertidas e interactivas que invitan a la familia a explorar y descubrir. Su rol es transformar los datos hist√≥ricos y las historias m√°gicas en acertijos, misiones y retos para los ni√±os.",
        goal="Convertir la visita a cada lugar en un juego o una misi√≥n. Su objetivo es proponer actividades que mantengan a los ni√±os (y a los adultos) activos y comprometidos, garantizando que el aprendizaje sea una experiencia inolvidable y llena de diversi√≥n.",
        backstory="Soy el 'cerebro' detr√°s de las aventuras del Rat√≥n P√©rez. Mi hogar est√° lleno de mapas, lupas y pergaminos secretos. Me encargo de que cada historia tenga un misterio por resolver y cada rinc√≥n de Madrid un desaf√≠o que superar. He creado juegos para pr√≠ncipes, exploradores y aventureros de todas las edades, y mi magia consiste en esconder pistas en los lugares m√°s inesperados.",
        llm=llm,
        verbose=True,
        allow_delegation=True,
        tools=[pdf_search_tool, internet_search_tool, location_search_tool]
    )
    
    # Crear tareas din√°micas basadas en la consulta del usuario
    research_task_coor = Task(
        description=(
            f"Incluye datos hist√≥ricos, arquitectura, curiosidades y leyendas. "
            f"Si se proporcionan listado de lugares cercanos {info_adicional} selecciona los mas relevantes y cercanos que se pueda ir a pie."
        ),
        expected_output="Crea una lista con los lugares mas relevantes y cercanos que se pueda ir a pie, que no supere los 3000 caracteres",
        agent=madrid_researcher,
    )
    research_task = Task(
        description=(
            f"Busca informaci√≥n detallada sobre: {user_query}. "
            f"Incluye datos hist√≥ricos, arquitectura, curiosidades y leyendas. "
            f"Si se proporcionan coordenadas ({lat}, {lon}), busca tambi√©n lugares cercanos."
        ),
        expected_output="Un documento de texto bien estructurado que contenga: Datos Hist√≥ricos Principales, Curiosidades y An√©cdotas, Leyendas M√°gicas. Formato: Markdown.",
        agent=madrid_researcher,
    )

    game_task = Task(
        description=(
            f"Usando la informaci√≥n proporcionada por el Madrid Cultural Researcher sobre: {user_query}, "
            f"dise√±a un acertijo o una pista de 'busca el tesoro' que sea divertida para ni√±os de 8 a 12 a√±os. "
            f"La pista debe estar relacionada con los lugares o actividades mencionadas en la consulta."
        ),
        expected_output="Un acertijo o pista bien formulada y un breve texto de apoyo que explique al gu√≠a d√≥nde y c√≥mo usarla durante el tour. Formato: Markdown.",
        agent=game_designer,
    )

    narrative_task = Task(
        description=(
            f"Utilizando la informaci√≥n hist√≥rica del Madrid Cultural Researcher y el juego del Adventure Game Designer, "
            f"crea una narrativa m√°gica y cautivadora para guiar a una familia sobre: {user_query}. "
            f"La narrativa debe ser c√°lida, cercana y llena de asombro. Debe mezclar hechos reales con cuentos fant√°sticos, "
            f"apelando a la curiosidad de los ni√±os y a la nostalgia de los adultos. "
            f"El resultado final debe ser un guion de tour inmersivo que invite a la familia a explorar y descubrir."
        ),
        expected_output="Un guion de tour completo en formato de narrativa que incluya: Una introducci√≥n, puntos de inter√©s clave con sus datos hist√≥ricos transformados en historias m√°gicas, la integraci√≥n del acertijo o juego, frases que inviten a la exploraci√≥n y una conclusi√≥n emotiva. Formato: Markdown.",
        agent=raton_perez_guide,
    )
    
    # Crear y ejecutar crew con los nuevos agentes
    crew = Crew(
        agents=[guia_turistico_raton, madrid_researcher, game_designer, raton_perez_guide],
        tasks=[research_task_coor, research_task, game_task, narrative_task],
        process=Process.sequential,
        verbose=True
    )
    
    print("\n" + "="*80)
    print("üéØ EJECUTANDO GU√çA TUR√çSTICA DE MADRID")
    print("ü§ñ Agente CrewAI con informaci√≥n integrada")
    fuentes = "üìö PDFs + üåê Internet"
    if lugares_info:
        fuentes += " + üåç OpenStreetMap"
    print(fuentes)
    print("="*80)
    
    # Ejecutar
    resultado = crew.kickoff()
    
    print("\n" + "="*80)
    print("üéâ GU√çA TUR√çSTICA GENERADA")
    print("üìã Informaci√≥n Pr√°ctica + Cultural integradas")
    print("="*80)
    print(resultado)
    
    # Guardar resultado en el directorio backend
    try:
        current_dir = os.path.dirname(os.path.abspath(__file__))
        backend_dir = os.path.join(current_dir, "..")
        output_file = os.path.join(backend_dir, "guia_madrid_final.md")
        
        with open(output_file, "w", encoding="utf-8") as f:
            f.write(f"# Gu√≠a Tur√≠stica de Madrid\n\n")
            f.write(f"**Consulta:** {user_query}\n\n")
            if lat and lon:
                f.write(f"**Coordenadas:** {lat}, {lon} (Radio: {radio_km}km)\n\n")
            f.write(f"**Generado por:** Agentes CrewAI colaborativos con Gemini\n\n")
            f.write(f"---\n\n{resultado}")
        print(f"üíæ Gu√≠a guardada en: {output_file}")
    except Exception as e:
        print(f"‚ö†Ô∏è Error guardando archivo: {e}")
    
    return resultado


def demo_openstreetmap():
    """
    Funci√≥n de demostraci√≥n para probar OpenStreetMap API sin entrada del usuario
    """
    print("üéØ DEMO: Probando OpenStreetMap Overpass API")
    print("=" * 50)
    
    # Coordenadas de ejemplo (Puerta del Sol)
    lat = 40.4170
    lon = -3.7036
    radio_metros = 1000  # 1km
    categoria = "turismo"
    
    print(f"üìç Coordenadas de prueba: {lat}, {lon}")
    print(f"üìè Radio: {radio_metros/1000}km")
    print(f"üè∑Ô∏è Categor√≠a: {categoria}")
    print()
    
    resultado = buscar_lugares_openstreetmap(lat, lon, radio_metros, categoria)
    print(resultado)
    
    return resultado


if __name__ == "__main__":
    import sys
    
    # Verificar si se pas√≥ argumento 'demo'
    if len(sys.argv) > 1 and sys.argv[1] == "demo":
        demo_openstreetmap()
        sys.exit(0)
    
    print("üöÄ Iniciando Agente CrewAI con Gemini + PDFs + Internet + OpenStreetMap...")
    print("üí° Tip: Ejecuta 'python agente_coordenadas.py demo' para probar solo OpenStreetMap API")
    
    # Configurar LLM
    llm = crear_llm_gemini()
    
    # Inicializar vectorstore
    vectorstore = inicializar_vectorstore()
    
    # Obtener consulta del usuario
    print("\nüåü ¬øQu√© te gustar√≠a saber sobre Madrid? (o presiona Enter para usar consulta por defecto): ", end="")
    
    try:
        user_query = input().strip()
    except EOFError:
        user_query = ""
    
    if not user_query:
        user_query = "mejores atracciones tur√≠sticas de Madrid"
    
    # Preguntar por b√∫squeda con coordenadas
    print("\nüìç ¬øQuieres buscar lugares cercanos usando coordenadas GPS? (s/n/ejemplo): ", end="")
    
    try:
        usar_coordenadas = input().strip().lower()
    except EOFError:
        usar_coordenadas = "ejemplo"  # Usar ejemplo por defecto si no hay entrada
    
    lat = None
    lon = None
    radio_km = 1.0
    categoria_foursquare = None
    
    if usar_coordenadas in ['s', 'si', 's√≠', 'yes', 'y']:
        try:
            print("\nüó∫Ô∏è Ingresa las coordenadas GPS:")
            print("   üìç Ejemplos de Madrid:")
            print("      ‚Ä¢ Puerta del Sol: 40.4170, -3.7036")
            print("      ‚Ä¢ Museo del Prado: 40.4138, -3.6921")
            print("      ‚Ä¢ Palacio Real: 40.4180, -3.7144")
            print("      ‚Ä¢ Parque del Retiro: 40.4153, -3.6844")
            
            lat_input = input("\n   üìç Latitud: ").strip()
            lon_input = input("   üìç Longitud: ").strip()
            
            lat = float(lat_input)
            lon = float(lon_input)
            
            # Radio de b√∫squeda
            radio_input = input(f"   üìè Radio de b√∫squeda en km (por defecto {radio_km}): ").strip()
            if radio_input:
                radio_km = float(radio_input)
            
            # Categor√≠a
            print("\nüìã Categor√≠as disponibles para OpenStreetMap:")
            print("   ‚Ä¢ museo, restaurante, hotel, parque, shopping, turismo, entretenimiento, cultura")
            categoria_input = input("   üè∑Ô∏è Filtrar por categor√≠a (opcional, Enter para todas): ").strip()
            if categoria_input:
                categoria_foursquare = categoria_input
            
            print(f"\n‚úÖ B√∫squeda con OpenStreetMap configurada:")
            print(f"   üìç Coordenadas: {lat}, {lon}")
            print(f"   üìè Radio: {radio_km}km")
            if categoria_foursquare:
                print(f"   üè∑Ô∏è Categor√≠a: {categoria_foursquare}")
                
        except (ValueError, EOFError):
            print("‚ùå Error: Coordenadas inv√°lidas. Continuando sin b√∫squeda por coordenadas.")
            lat = None
            lon = None
    
    # Ejemplo r√°pido para testing
    elif usar_coordenadas in ['ejemplo', 'test', 'demo', '']:
        print("üéØ Usando coordenadas de ejemplo (Puerta del Sol)")
        lat = 40.4170
        lon = -3.7036
        radio_km = 1.0
        categoria_foursquare = "turismo"
        print(f"‚úÖ Configuraci√≥n de ejemplo: {lat}, {lon} - Radio: {radio_km}km - Categor√≠a: {categoria_foursquare}")
    
    # Ejecutar agente principal
    main(user_query, vectorstore, llm, 
         lat=lat, 
         lon=lon, 
         radio_km=radio_km,
         categoria_foursquare=categoria_foursquare)
